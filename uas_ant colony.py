# -*- coding: utf-8 -*-
"""UAS 4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ze8m3b7p9KBCLHlOq_8r-ZVJLSb9B6T1
"""

import random

# Define constants
MAX_ITER = 100
ANT_COUNT = 10
EVAPORATION_RATE = 0.5
PHEROMONE_WEIGHT = 1.0
HEURISTIC_WEIGHT = 2.0

# Define schedule constraints
days = ["Senin", "Selasa", "Rabu", "Kamis", "Jumâ€™at"]
hours = ["13:00", "15:45"]
kelas = ["RSGU", "1210"]

# Define the schedule data
schedule_data = [
    ("EP", "Analisis Multivariat"), ("EP", "Kualitas Jasa"), ("EP", "Manajemen Kualitas"),
    ("SS", "Metode Optimasi"), ("SS", "Kreativitas dan Inovasi Produk"),
    ("WAJ", "Pemodelan Sistem"),
    ("PWL", "Pemrograman dan Komputasi"), ("PWL", "Analitika Data"),
    ("WS", "Sistem Logistik dan Rekayasa Bisnis"), ("WS", "Perancangan Jaringan Rantai Pasok"),
    ("EL", "Perancangan E-Bisnis"),
    ("RWD", "Manajemen Proyek Berkelanjutan"),
    ("CNR", "Penjadwalan Produksi"),
    ("BS", "Rekayasa Faktor Manusia dan Ergonomi"), ("BS", "Aplikasi Ergonomi Industri"),
    ("RR", "Manajemen Investasi dan Kewirausahaan"),
]

# Define the initial pheromone level for each edge (day, hour)
initial_pheromone = 1.0
pheromone_levels = {(day, hour, kls): initial_pheromone for day in days for hour in hours for kls in kelas}

def calculate_total_fitness(schedule):
    conflicts = 0
    for day, hours in schedule.items():
        for hour, courses in hours.items():
            if len(courses) > 1:
                conflicts += 1
    return 1 / (conflicts + 1)

def select_course_based_on_probability(probabilities):
    rand = random.uniform(0, sum(probabilities))
    total = 0
    for i, prob in enumerate(probabilities):
        total += prob
        if rand < total:
            return i

def select_course(schedule):
    available_days = [day for day in days if any(len(schedule[day][hour]) < 2 for hour in hours)]
    if not available_days:
        return None, None, None

    day = random.choice(available_days)
    available_hours = [hour for hour in hours if len(schedule[day][hour]) < 2]
    hour = random.choice(available_hours)
    available_kelas = [kelas for kelas in kelas if (day, hour, kelas) in pheromone_levels and not any(course[0] == (day, hour) for courses in schedule[day].values() for course in courses)]

    if not available_kelas:
        return None, None, None

    selected_kelas = random.choice(available_kelas)
    return day, hour, selected_kelas

def ant_colony_algorithm():
    global pheromone_levels

    for iteration in range(MAX_ITER):
        ant_solutions = [{'schedule': {day: {hour: [] for hour in hours} for day in days}, 'fitness': 0.0} for _ in range(ANT_COUNT)]

        for ant in ant_solutions:
            for _ in range(len(schedule_data)):
                day, hour, selected_kelas = select_course(ant['schedule'])
                if day is not None and hour is not None:
                    course_index = select_course_based_on_probability(generate_probabilities(ant['schedule'], day, hour, selected_kelas))
                    ant['schedule'][day][hour].append((schedule_data[course_index], selected_kelas))
                    ant['fitness'] = calculate_total_fitness(ant['schedule'])

        update_pheromone_levels(ant_solutions)

    best_schedule = max(ant_solutions, key=lambda x: x['fitness'])['schedule']
    return best_schedule

def generate_probabilities(schedule, selected_day, selected_hour, selected_kelas):
    global pheromone_levels

    probabilities = []
    total = 0

    for i, course in enumerate(schedule_data):
        day, hour, kelas = selected_day, selected_hour, selected_kelas

        if (day, hour, kelas) in pheromone_levels:
            pheromone = pheromone_levels[(day, hour, kelas)]
            heuristic = 1 / (1 + len(schedule[day][hour]))
            total += (pheromone ** PHEROMONE_WEIGHT) * (heuristic ** HEURISTIC_WEIGHT)

    for i, course in enumerate(schedule_data):
        day, hour, kelas = selected_day, selected_hour, selected_kelas

        if (day, hour, kelas) in pheromone_levels:
            pheromone = pheromone_levels[(day, hour, kelas)]
            heuristic = 1 / (1 + len(schedule[day][hour]))
            probability = (pheromone ** PHEROMONE_WEIGHT) * (heuristic ** HEURISTIC_WEIGHT) / total
            probabilities.append(probability)
        else:
            probabilities.append(0.0)

    return probabilities

def update_pheromone_levels(ant_solutions):
    global pheromone_levels

    # Evaporation
    for key in pheromone_levels:
        pheromone_levels[key] *= (1 - EVAPORATION_RATE)

    # Pheromone deposition by the ants
    for ant in ant_solutions:
        for day, hours in ant['schedule'].items():
            for hour, courses in hours.items():
                if courses:
                    for course, kelas in courses:
                        if (day, hour, kelas) in pheromone_levels:
                            # Use the inverse of fitness to update pheromone levels
                            pheromone_levels[(day, hour, kelas)] += 1 / ant['fitness']

# Run the Ant Colony Optimization algorithm
best_schedule = ant_colony_algorithm()

# Print the final schedule
for day, hours in best_schedule.items():
    for hour, courses in hours.items():
        for course, kelas in courses:
            print(f"{day}, {hour}, {kelas}: {course}")